/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/providers/googleMap/GoogleMap.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@google/markerwithlabel/src/markerwithlabel.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@google/markerwithlabel/src/markerwithlabel.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @name MarkerWithLabel for V3\n * @version 1.2.3\n * @author Gary Little (inspired by code from Marc Ridey of Google).\n * @copyright Copyright 2012 Gary Little [gary at luxcentral.com]\n * @fileoverview MarkerWithLabel extends the Google Maps JavaScript API V3\n *  <code>google.maps.Marker</code> class.\n *  <p>\n *  MarkerWithLabel allows you to define markers with associated labels. As you would expect,\n *  if the marker is draggable, so too will be the label. In addition, a marker with a label\n *  responds to all mouse events in the same manner as a regular marker. It also fires mouse\n *  events and \"property changed\" events just as a regular marker would.\n */\n\n/*!\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*jslint browser:true */\n/*global document,google */\n\n/**\n * @param {Function} childCtor Child class.\n * @param {Function} parentCtor Parent class.\n * @private\n */\nfunction inherits(childCtor, parentCtor) {\n  /* @constructor */\n  function tempCtor() {}\n  tempCtor.prototype = parentCtor.prototype;\n  childCtor.superClass_ = parentCtor.prototype;\n  childCtor.prototype = new tempCtor();\n  /* @override */\n  childCtor.prototype.constructor = childCtor;\n}\n\n/**\n * This constructor creates a label and associates it with a marker.\n * It is for the private use of the MarkerWithLabel class.\n * @constructor\n * @param {Marker} marker The marker with which the label is to be associated.\n * @param {string} crossURL The URL of the cross image =.\n * @private\n */\nfunction MarkerLabel_(marker, crossURL) {\n  this.marker_ = marker;\n\n  this.labelDiv_ = document.createElement(\"div\");\n  this.labelDiv_.style.cssText = \"position: absolute; overflow: hidden;\";\n\n  // Set up the DIV for handling mouse events in the label. This DIV forms a transparent veil\n  // in the \"overlayMouseTarget\" pane, a veil that covers just the label. This is done so that\n  // events can be captured even if the label is in the shadow of a google.maps.InfoWindow.\n  // Code is included here to ensure the veil is always exactly the same size as the label.\n  this.eventDiv_ = document.createElement(\"div\");\n  this.eventDiv_.style.cssText = this.labelDiv_.style.cssText;\n\n  // This is needed for proper behavior on MSIE:\n  this.eventDiv_.setAttribute(\"onselectstart\", \"return false;\");\n  this.eventDiv_.setAttribute(\"ondragstart\", \"return false;\");\n\n  // Get the DIV for the \"X\" to be displayed when the marker is raised.\n  this.crossDiv_ = MarkerLabel_.getSharedCross(crossURL);\n}\n\nif (typeof google !== 'undefined') {\n  inherits(MarkerLabel_, google.maps.OverlayView);\n}\n\n\n/**\n * Returns the DIV for the cross used when dragging a marker when the\n * crossOnDrag parameter set to true. One cross is shared with all markers.\n * @param {string} crossURL The URL of the cross image.\n * @private\n */\nMarkerLabel_.getSharedCross = function (crossURL) {\n  var div;\n  if (typeof MarkerLabel_.getSharedCross.crossDiv === \"undefined\") {\n    div = document.createElement(\"img\");\n    div.style.cssText = \"position: absolute; z-index: 1000002; display: none;\";\n    // Hopefully Google never changes the standard \"X\" attributes:\n    div.style.marginLeft = \"-8px\";\n    div.style.marginTop = \"-9px\";\n    div.src = crossURL;\n    MarkerLabel_.getSharedCross.crossDiv = div;\n  }\n  return MarkerLabel_.getSharedCross.crossDiv;\n};\n\n/**\n * Adds the DIV representing the label to the DOM. This method is called\n * automatically when the marker's <code>setMap</code> method is called.\n * @private\n */\nMarkerLabel_.prototype.onAdd = function () {\n  var me = this;\n\n  this.getPanes().markerLayer.appendChild(this.labelDiv_);\n  this.getPanes().overlayMouseTarget.appendChild(this.eventDiv_);\n  // One cross is shared with all markers, so only add it once:\n  if (typeof MarkerLabel_.getSharedCross.processed === \"undefined\") {\n    this.getPanes().overlayImage.appendChild(this.crossDiv_);\n    MarkerLabel_.getSharedCross.processed = true;\n  }\n\n  this.addMouseListeners();\n\n  this.listeners2_ = [\n    google.maps.event.addListener(this.marker_, \"clickable_changed\", function () {\n      me.setClickable();\n    }),\n    google.maps.event.addListener(this.marker_, \"cursor_changed\", function () {\n      me.setCursor();\n    }),\n    google.maps.event.addListener(this.marker_, \"draggable_changed\", function () {\n      me.setClickable();\n    }),\n    google.maps.event.addListener(this.marker_, \"position_changed\", function () {\n      me.setPosition();\n    }),\n    google.maps.event.addListener(this.marker_, \"visible_changed\", function () {\n      me.setVisible();\n    }),\n    google.maps.event.addListener(this.marker_, \"title_changed\", function () {\n      me.setTitle();\n    }),\n    google.maps.event.addListener(this.marker_, \"zindex_changed\", function () {\n      me.setZIndex();\n    }),\n    google.maps.event.addListener(this.marker_, \"labelanchor_changed\", function () {\n      me.setAnchor();\n    }),\n    google.maps.event.addListener(this.marker_, \"labelclass_changed\", function () {\n      me.setStyles();\n    }),\n    google.maps.event.addListener(this.marker_, \"labelcontent_changed\", function () {\n      me.setContent();\n    }),\n    google.maps.event.addListener(this.marker_, \"labelstyle_changed\", function () {\n      me.setStyles();\n    }),\n    google.maps.event.addListener(this.marker_, \"labelvisible_changed\", function () {\n      me.setVisible();\n    })\n  ];\n};\n\n/**\n * Adds the listeners for a clickable label.\n * @private\n */\nMarkerLabel_.prototype.addMouseListeners = function () {\n  var me = this;\n  var cTouchScreen = false;\n  var cMouseIsDown = false;\n  var cDraggingLabel = false;\n  var cIgnoreClick;\n  var cLatOffset, cLngOffset;\n\n  // Stop all processing of an event.\n  //\n  var cAbortEvent = function (e) {\n    e = e || window.event;\n    if (e.stopPropagation) {\n      e.stopPropagation();\n    } else {\n      e.cancelBubble = true;\n    }\n    if (e.preventDefault) {\n      e.preventDefault();\n    } else {\n      e.returnValue = false;\n    }\n  };\n\n  // Stop an event from propagating.\n  //\n  var cStopPropagation = function (e) {\n    e = e || window.event;\n    if (e.stopPropagation) {\n      e.stopPropagation();\n    } else {\n      e.cancelBubble = true;\n    }\n  };\n\n  this.listeners1_ = [\n    google.maps.event.addDomListener(this.eventDiv_, \"mouseover\", function (e) {\n      var mEvent = {latLng: me.marker_.getPosition()};\n      if (me.marker_.getClickable() || me.marker_.getDraggable()) {\n        if (!cTouchScreen) {\n          this.style.cursor = (me.marker_.getCursor() || \"pointer\");\n          google.maps.event.trigger(me.marker_, \"mouseover\", mEvent);\n          cAbortEvent(e);\n        }\n      } else {\n        this.style.cursor = null;\n      }\n    }),\n    google.maps.event.addDomListener(this.eventDiv_, \"mouseout\", function (e) {\n      var mEvent = {latLng: me.marker_.getPosition()};\n      if (me.marker_.getClickable() || me.marker_.getDraggable()) {\n        if (!cTouchScreen) {\n          google.maps.event.trigger(me.marker_, \"mouseout\", mEvent);\n          cAbortEvent(e);\n        }\n      }\n    }),\n    google.maps.event.addDomListener(this.eventDiv_, \"mousedown\", function (e) {\n      var mEvent = {latLng: me.marker_.getPosition()};\n      cDraggingLabel = false;\n      if (me.marker_.getClickable() || me.marker_.getDraggable()) {\n        cMouseIsDown = true;\n        google.maps.event.trigger(me.marker_, \"mousedown\", mEvent);\n        if (!cTouchScreen) {\n          cAbortEvent(e); // Prevent map pan when starting a drag on a label\n        }\n      }\n    }),\n    google.maps.event.addDomListener(this.eventDiv_, \"mouseup\", function (e) {\n      var mEvent = {latLng: me.marker_.getPosition()};\n      if (cMouseIsDown) {\n        cMouseIsDown = false;\n        google.maps.event.trigger(me.marker_, \"mouseup\", mEvent);\n        if (cDraggingLabel) {\n          cDraggingLabel = false;\n          me.crossDiv_.style.display = \"none\";\n          cIgnoreClick = true; // Set flag to ignore the click event reported after a label drag\n          google.maps.event.trigger(me.marker_, \"dragend\", mEvent);\n        }\n        if (!me.marker_.getDraggable()) {\n          cAbortEvent(e);\n        }\n      }\n    }),\n    google.maps.event.addDomListener(this.eventDiv_, \"click\", function (e) {\n      var mEvent = {latLng: me.marker_.getPosition()};\n      if (me.marker_.getClickable() || me.marker_.getDraggable()) {\n        if (cIgnoreClick) { // Ignore the click reported when a label drag ends\n          cIgnoreClick = false;\n        } else {\n          google.maps.event.trigger(me.marker_, \"click\", mEvent);\n        }\n        cAbortEvent(e); // Prevent click from being passed on to map\n      }\n    }),\n    google.maps.event.addDomListener(this.eventDiv_, \"dblclick\", function (e) {\n      var mEvent = {latLng: me.marker_.getPosition()};\n      if (me.marker_.getClickable() || me.marker_.getDraggable()) {\n        google.maps.event.trigger(me.marker_, \"dblclick\", mEvent);\n        cAbortEvent(e); // Prevent map zoom when double-clicking on a label\n      }\n    }),\n    google.maps.event.addListener(this.marker_.getMap(), \"mousemove\", function (mEvent) {\n      var position;\n      if (cMouseIsDown && me.marker_.getDraggable()) {\n        if (cDraggingLabel) {\n          // Change the reported location from the mouse position to the marker position:\n          mEvent.latLng = new google.maps.LatLng(mEvent.latLng.lat() - cLatOffset, mEvent.latLng.lng() - cLngOffset);\n          if (me.marker_.get(\"crossOnDrag\")) { // Position and display the cross\n            position = me.getProjection().fromLatLngToDivPixel(mEvent.latLng);\n            me.crossDiv_.style.left = position.x + \"px\";\n            me.crossDiv_.style.top = position.y + \"px\";\n            me.crossDiv_.style.display = \"\";\n          }\n          google.maps.event.trigger(me.marker_, \"drag\", mEvent);\n        } else {\n          // Calculate offsets from the click point to the marker position:\n          cLatOffset = mEvent.latLng.lat() - me.marker_.getPosition().lat();\n          cLngOffset = mEvent.latLng.lng() - me.marker_.getPosition().lng();\n          cDraggingLabel = true;\n          mEvent.latLng = me.marker_.getPosition();\n          google.maps.event.trigger(me.marker_, \"dragstart\", mEvent);\n        }\n      }\n    }),\n    google.maps.event.addListener(this.marker_, \"dragstart\", function (mEvent) {\n      // During a drag, the marker's z-index is temporarily set to 1000000 to ensure\n      // it appears above all other markers. Here we also set the label's z-index\n      // to 1000000 (plus or minus 1 depending on whether the label is supposed\n      // to be above or below the marker). (NOTE: For some reason, Google does not\n      // fire a zindex_changed event when changing the marker's z-index to 100000\n      // or else this task would be handled by the MarkerLabel_.setZIndex() method.)\n      //\n      me.labelDiv_.style.zIndex = 1000000 + (this.get(\"labelInBackground\") ? -1 : +1);\n      me.eventDiv_.style.zIndex = me.labelDiv_.style.zIndex;\n    }),\n    google.maps.event.addListener(this.marker_, \"drag\", function (mEvent) {\n      this.setPosition(mEvent.latLng);\n    }),\n    google.maps.event.addListener(this.marker_, \"dragend\", function (mEvent) {\n      me.setZIndex();\n    }),\n    // Prevent touch events from passing through the label DIV to the underlying map.\n    //\n    google.maps.event.addDomListener(this.eventDiv_, \"touchstart\", function (e) {\n      cTouchScreen = true;\n      cStopPropagation(e);\n    }),\n    google.maps.event.addDomListener(this.eventDiv_, \"touchmove\", function (e) {\n      cStopPropagation(e);\n    }),\n    google.maps.event.addDomListener(this.eventDiv_, \"touchend\", function (e) {\n      cStopPropagation(e);\n    })\n  ];\n};\n\n/**\n * Removes the listeners for a clickable label.\n * @private\n */\nMarkerLabel_.prototype.removeMouseListeners = function () {\n  var i;\n\n  if (this.listeners1_) {\n    for (i = 0; i < this.listeners1_.length; i++) {\n      google.maps.event.removeListener(this.listeners1_[i]);\n    }\n  }\n};\n\n/**\n * Removes the DIV for the label from the DOM. It also removes all event handlers.\n * This method is called automatically when the marker's <code>setMap(null)</code>\n * method is called.\n * @private\n */\nMarkerLabel_.prototype.onRemove = function () {\n  var i;\n  if (this.labelDiv_.parentNode) {\n    this.labelDiv_.parentNode.removeChild(this.labelDiv_);\n  }\n  if (this.eventDiv_.parentNode) {\n    this.eventDiv_.parentNode.removeChild(this.eventDiv_);\n  }\n  // Remove event listeners:\n  this.removeMouseListeners();\n\n  if (this.listeners2_) {\n    for (i = 0; i < this.listeners2_.length; i++) {\n      google.maps.event.removeListener(this.listeners2_[i]);\n    }\n  }\n};\n\n/**\n * Draws the label on the map.\n * @private\n */\nMarkerLabel_.prototype.draw = function () {\n  this.setContent();\n  this.setTitle();\n  this.setStyles();\n};\n\n/**\n * Sets the content of the label.\n * The content can be plain text or an HTML DOM node.\n * @private\n */\nMarkerLabel_.prototype.setContent = function () {\n  var content = this.marker_.get(\"labelContent\");\n  var previousContent = this.marker_._previousContent;\n  if(previousContent !== content){\n    this.marker_._previousContent = content;\n    if (typeof content.nodeType === \"undefined\") {\n      this.labelDiv_.innerHTML = content;\n      this.eventDiv_.innerHTML = this.labelDiv_.innerHTML;\n    } else {\n      this.labelDiv_.innerHTML = \"\"; // Remove current content\n      this.labelDiv_.appendChild(content);\n      content = content.cloneNode(true);\n      this.eventDiv_.innerHTML = \"\"; // Remove current content\n      this.eventDiv_.appendChild(content);\n    }\n  }\n};\n\n/**\n * Sets the content of the tool tip for the label. It is\n * always set to be the same as for the marker itself.\n * @private\n */\nMarkerLabel_.prototype.setTitle = function () {\n  this.eventDiv_.title = this.marker_.getTitle() || \"\";\n};\n\n/**\n * Sets the style of the label by setting the style sheet and applying\n * other specific styles requested.\n * @private\n */\nMarkerLabel_.prototype.setStyles = function () {\n  var i, labelStyle;\n\n  // Apply style values from the style sheet defined in the labelClass parameter:\n  this.labelDiv_.className = this.marker_.get(\"labelClass\");\n  this.eventDiv_.className = this.labelDiv_.className;\n\n  // Clear existing inline style values:\n  this.labelDiv_.style.cssText = \"\";\n  this.eventDiv_.style.cssText = \"\";\n  // Apply style values defined in the labelStyle parameter:\n  labelStyle = this.marker_.get(\"labelStyle\");\n  for (i in labelStyle) {\n    if (labelStyle.hasOwnProperty(i)) {\n      this.labelDiv_.style[i] = labelStyle[i];\n      this.eventDiv_.style[i] = labelStyle[i];\n    }\n  }\n  this.setMandatoryStyles();\n};\n\n/**\n * Sets the mandatory styles to the DIV representing the label as well as to the\n * associated event DIV. This includes setting the DIV position, z-index, and visibility.\n * @private\n */\nMarkerLabel_.prototype.setMandatoryStyles = function () {\n  this.labelDiv_.style.position = \"absolute\";\n  this.labelDiv_.style.overflow = \"hidden\";\n  // Make sure the opacity setting causes the desired effect on MSIE:\n  if (typeof this.labelDiv_.style.opacity !== \"undefined\" && this.labelDiv_.style.opacity !== \"\") {\n    this.labelDiv_.style.MsFilter = \"\\\"progid:DXImageTransform.Microsoft.Alpha(opacity=\" + (this.labelDiv_.style.opacity * 100) + \")\\\"\";\n    this.labelDiv_.style.filter = \"alpha(opacity=\" + (this.labelDiv_.style.opacity * 100) + \")\";\n  }\n\n  this.eventDiv_.style.position = this.labelDiv_.style.position;\n  this.eventDiv_.style.overflow = this.labelDiv_.style.overflow;\n  this.eventDiv_.style.cursor = \"pointer\"; // Required to make this clickable on iOS\n  this.eventDiv_.style.opacity = 0.01; // Don't use 0; DIV won't be clickable on MSIE\n  this.eventDiv_.style.MsFilter = \"\\\"progid:DXImageTransform.Microsoft.Alpha(opacity=1)\\\"\";\n  this.eventDiv_.style.filter = \"alpha(opacity=1)\"; // For MSIE\n\n  this.setAnchor();\n  this.setPosition();\n  this.setZIndex();\n  this.setVisible();\n};\n\n/**\n * Sets the anchor point of the label.\n * @private\n */\nMarkerLabel_.prototype.setAnchor = function () {\n  var anchor = this.marker_.get(\"labelAnchor\");\n  this.labelDiv_.style.marginLeft = -anchor.x + \"px\";\n  this.labelDiv_.style.marginTop = -anchor.y + \"px\";\n  this.eventDiv_.style.marginLeft = -anchor.x + \"px\";\n  this.eventDiv_.style.marginTop = -anchor.y + \"px\";\n};\n\n/**\n * Sets the position of the label. The z-index is also updated, if necessary.\n * @private\n */\nMarkerLabel_.prototype.setPosition = function () {\n  var position = this.getProjection().fromLatLngToDivPixel(this.marker_.getPosition());\n  this.labelDiv_.style.left = Math.round(position.x) + \"px\";\n  this.labelDiv_.style.top = Math.round(position.y) + \"px\";\n  this.eventDiv_.style.left = this.labelDiv_.style.left;\n  this.eventDiv_.style.top = this.labelDiv_.style.top;\n};\n\n/**\n * Sets the z-index of the label. If the marker's z-index property has not been defined, the z-index\n * of the label is set to the vertical coordinate of the label. This is in keeping with the default\n * stacking order for Google Maps: markers to the south are in front of markers to the north.\n * @private\n */\nMarkerLabel_.prototype.setZIndex = function () {\n  var zAdjust = (this.marker_.get(\"labelInBackground\") ? -1 : +1);\n  if (typeof this.marker_.getZIndex() === \"undefined\") {\n    this.labelDiv_.style.zIndex = parseInt(this.labelDiv_.style.top, 10) + zAdjust;\n    this.eventDiv_.style.zIndex = this.labelDiv_.style.zIndex;\n  } else {\n    this.labelDiv_.style.zIndex = this.marker_.getZIndex() + zAdjust;\n    this.eventDiv_.style.zIndex = this.labelDiv_.style.zIndex;\n  }\n};\n\n/**\n * Sets the clickability of the label. The label is clickable only if the\n * marker itself is clickable (i.e., its clickable property is true) or if\n * it is draggable (i.e., its draggable property is true).\n * @private\n */\nMarkerLabel_.prototype.setClickable = function () {\n  this.removeMouseListeners();\n  this.eventDiv_.style.cursor = null;\n  if (this.marker_.getClickable() || this.marker_.getDraggable()) {\n    this.addMouseListeners();\n  }\n};\n\n/**\n * Sets the cursor for the label.\n * @private\n */\nMarkerLabel_.prototype.setCursor = function () {\n  this.eventDiv_.style.cursor = this.marker_.getCursor();\n};\n\n/**\n * Sets the visibility of the label. The label is visible only if the marker itself is\n * visible (i.e., its visible property is true) and the labelVisible property is true.\n * @private\n */\nMarkerLabel_.prototype.setVisible = function () {\n  if (this.marker_.get(\"labelVisible\")) {\n    this.labelDiv_.style.display = this.marker_.getVisible() ? \"block\" : \"none\";\n  } else {\n    this.labelDiv_.style.display = \"none\";\n  }\n  this.eventDiv_.style.display = this.labelDiv_.style.display;\n};\n\n/**\n * @name MarkerWithLabelOptions\n * @class This class represents the optional parameter passed to the {@link MarkerWithLabel} constructor.\n *  The properties available are the same as for <code>google.maps.Marker</code> with the addition\n *  of the properties listed below. To change any of these additional properties after the labeled\n *  marker has been created, call <code>google.maps.Marker.set(propertyName, propertyValue)</code>.\n *  <p>\n *  When any of these properties changes, a property changed event is fired. The names of these\n *  events are derived from the name of the property and are of the form <code>propertyname_changed</code>.\n *  For example, if the content of the label changes, a <code>labelcontent_changed</code> event\n *  is fired.\n *  <p>\n * @property {string|Node} [labelContent] The content of the label (plain text or an HTML DOM node).\n * @property {Point} [labelAnchor] By default, a label is drawn with its anchor point at (0,0) so\n *  that its top left corner is positioned at the anchor point of the associated marker. Use this\n *  property to change the anchor point of the label. For example, to center a 50px-wide label\n *  beneath a marker, specify a <code>labelAnchor</code> of <code>google.maps.Point(25, 0)</code>.\n *  (Note: x-values increase to the right and y-values increase to the top.)\n * @property {string} [labelClass] The name of the CSS class defining the styles for the label.\n *  Note that style values for <code>position</code>, <code>overflow</code>, <code>top</code>,\n *  <code>left</code>, <code>zIndex</code>, <code>display</code>, <code>marginLeft</code>, and\n *  <code>marginTop</code> are ignored; these styles are for internal use only.\n * @property {Object} [labelStyle] An object literal whose properties define specific CSS\n *  style values to be applied to the label. Style values defined here override those that may\n *  be defined in the <code>labelClass</code> style sheet. If this property is changed after the\n *  label has been created, all previously set styles (except those defined in the style sheet)\n *  are removed from the label before the new style values are applied.\n *  Note that style values for <code>position</code>, <code>overflow</code>, <code>top</code>,\n *  <code>left</code>, <code>zIndex</code>, <code>display</code>, <code>marginLeft</code>, and\n *  <code>marginTop</code> are ignored; these styles are for internal use only.\n * @property {boolean} [labelInBackground] A flag indicating whether a label that overlaps its\n *  associated marker should appear in the background (i.e., in a plane below the marker).\n *  The default is <code>false</code>, which causes the label to appear in the foreground.\n * @property {boolean} [labelVisible] A flag indicating whether the label is to be visible.\n *  The default is <code>true</code>. Note that even if <code>labelVisible</code> is\n *  <code>true</code>, the label will <i>not</i> be visible unless the associated marker is also\n *  visible (i.e., unless the marker's <code>visible</code> property is <code>true</code>).\n * @property {boolean} [crossOnDrag] A flag indicating whether a cross (\"X\") is to be\n *  shown when the marker label is dragged. The default is <code>true</code>. The marker\n *  is placed at the position of the cross when the drag ends.\n * @property {boolean} [optimized] A flag indicating whether rendering is to be optimized\n *  for the marker. <b>Important: The optimized rendering technique is not supported by\n *  MarkerWithLabel, so the value of this parameter is always forced to <code>false</code>.\n * @property {string} [crossImage=\"//maps.gstatic.com/intl/en_us/mapfiles/drag_cross_67_16.png\"]\n *  The URL of the cross image to be displayed while dragging a marker.\n */\n/**\n * Creates a MarkerWithLabel with the options specified in {@link MarkerWithLabelOptions}.\n * @constructor\n * @param {MarkerWithLabelOptions} [opt_options] The optional parameters.\n */\nfunction MarkerWithLabel(opt_options) {\n  opt_options = opt_options || {};\n  opt_options.labelContent = opt_options.labelContent || \"\";\n  opt_options.labelAnchor = opt_options.labelAnchor || new google.maps.Point(0, 0);\n  opt_options.labelClass = opt_options.labelClass || \"markerLabels\";\n  opt_options.labelStyle = opt_options.labelStyle || {};\n  opt_options.labelInBackground = opt_options.labelInBackground || false;\n  if (typeof opt_options.labelVisible === \"undefined\") {\n    opt_options.labelVisible = true;\n  }\n  if (typeof opt_options.crossOnDrag === \"undefined\") {\n    opt_options.crossOnDrag = true;\n  }\n  if (typeof opt_options.clickable === \"undefined\") {\n    opt_options.clickable = true;\n  }\n  if (typeof opt_options.draggable === \"undefined\") {\n    opt_options.draggable = false;\n  }\n  if (typeof opt_options.optimized === \"undefined\") {\n    opt_options.optimized = false;\n  }\n  opt_options.crossImage = opt_options.crossImage || \"//maps.gstatic.com/intl/en_us/mapfiles/drag_cross_67_16.png\";\n  opt_options.optimized = false; // Optimized rendering is not supported\n\n  this.label = new MarkerLabel_(this, opt_options.crossImage); // Bind the label to the marker\n\n  // Call the parent constructor. It calls Marker.setValues to initialize, so all\n  // the new parameters are conveniently saved and can be accessed with get/set.\n  // Marker.set triggers a property changed event (called \"propertyname_changed\")\n  // that the marker label listens for in order to react to state changes.\n  google.maps.Marker.apply(this, arguments);\n}\n\nif (typeof google !== 'undefined') {\n  inherits(MarkerWithLabel, google.maps.Marker);\n}\n\n/**\n * Overrides the standard Marker setMap function.\n * @param {Map} theMap The map to which the marker is to be added.\n * @private\n */\nMarkerWithLabel.prototype.setMap = function (theMap) {\n\n  // Call the inherited function...\n  google.maps.Marker.prototype.setMap.apply(this, arguments);\n\n  // ... then deal with the label:\n  this.label.setMap(theMap);\n};\n\nif (true) {\n  module.exports = MarkerWithLabel;\n}\n\n\n//# sourceURL=webpack:///./node_modules/@google/markerwithlabel/src/markerwithlabel.js?");

/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/style.css":
/*!*************************************************!*\
  !*** ./node_modules/css-loader!./src/style.css ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../node_modules/css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")();\nexports.push([module.i, \".one-map-to-rule-them-all__spinner {\\n    position: absolute;\\n    top: 0;\\n    right: 0;\\n    bottom: 0;\\n    left: 0;\\n    content: '';\\n    width: 50px;\\n    height: 50px;\\n    margin: auto;\\n    padding: 50px 0 0 50px;\\n    background-color: #333;\\n\\n    border-radius: 100%;\\n    animation: scaleout 1.0s infinite ease-in-out;\\n}\\n\\n@keyframes scaleout {\\n    0% {\\n        transform: scale(0.0);\\n    } 100% {\\n          transform: scale(1.0);\\n          opacity: 0;\\n      }\\n}\\n\", \"\"]);\n\n//# sourceURL=webpack:///./src/style.css?./node_modules/css-loader");

/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/css-loader/lib/css-base.js?");

/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction ToObject(val) {\n\tif (val == null) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction ownEnumerableKeys(obj) {\n\tvar keys = Object.getOwnPropertyNames(obj);\n\n\tif (Object.getOwnPropertySymbols) {\n\t\tkeys = keys.concat(Object.getOwnPropertySymbols(obj));\n\t}\n\n\treturn keys.filter(function (key) {\n\t\treturn propIsEnumerable.call(obj, key);\n\t});\n}\n\nmodule.exports = Object.assign || function (target, source) {\n\tvar from;\n\tvar keys;\n\tvar to = ToObject(target);\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = arguments[s];\n\t\tkeys = ownEnumerableKeys(Object(from));\n\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tto[keys[i]] = from[keys[i]];\n\t\t}\n\t}\n\n\treturn to;\n};\n\n\n//# sourceURL=webpack:///./node_modules/object-assign/index.js?");

/***/ }),

/***/ "./node_modules/simple-js-validator/lib/simple.js.validator.js":
/*!*********************************************************************!*\
  !*** ./node_modules/simple-js-validator/lib/simple.js.validator.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\r\n * Simple.Js.Validator v0.12.3\r\n *\r\n * @class Validator\r\n * A collection of simple validations for common actions\r\n *\r\n * @type {SimpleJS.Validator}\r\n */\r\n\r\n(function(exports) {\r\n  \"use strict\";\r\n\r\n  /**\r\n   * Returns ***true*** if the value is empty; otherwise, returns ***false***.\r\n   *\r\n   * Returns ***true*** for the following:\r\n   *\r\n   *  - typeof undefined\r\n   *  - null\r\n   *  - NaN\r\n   *  - '' (empty string)\r\n   *  - {} (empty object)\r\n   *  - [] (empty array)\r\n   *\r\n   * Returns ***false*** for the following:\r\n   *\r\n   *  - 0\r\n   *  - false\r\n   *  - anything else\r\n   *\r\n   * @param {Object} value         value to check\r\n   * @returns {boolean}   true if empty; false if not empty\r\n   */\r\n  var isEmpty = exports.isEmpty = function(value) {\r\n\r\n    if (typeof value === 'undefined') {\r\n      return true;\r\n    } else if (value === null) {\r\n      return true;\r\n    } else if (isNAN(value)) {\r\n      return true;\r\n    } else if (value === '') {\r\n      return true;\r\n    } else if (value === 0) {\r\n      return false;\r\n    } else if (value === false) {\r\n      return false;\r\n    } else if (isDate(value)) {\r\n      // new Date() is an object, but it has no keys/props so it will fail the isObject check\r\n      // so if it is a date, it is considered populated\r\n      // also the for loop with the hasOwnProperty did not pass the new Date() either\r\n      // also the _.isEmpty did not pass the new Date() check\r\n      // ...could use _.isDate, but trying to reduce the dependency on external libs\r\n      return false;\r\n    } else if (isError(value)) {\r\n      // new Error() is an object, but it has no keys/props so it will fail the isObject\r\n      // so if it is an error, it is considered populated\r\n      return false;\r\n    } else if (isEmptyObject(value)) {\r\n      // this did not pass the new Date() check by itself, so added the date check above\r\n      // this did not pass the new Error() check by itself, so added the error check above\r\n      return true;\r\n    } else if (isEmptyArray(value)) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Returns ***true*** if the value is not empty; otherwise, returns ***false***.\r\n   *\r\n   * Returns ***false*** for the following:\r\n   *\r\n   *  - typeof undefined\r\n   *  - null\r\n   *  - NaN\r\n   *  - '' (empty string)\r\n   *  - {} (empty object)\r\n   *  - [] (empty array)\r\n   *\r\n   * Returns ***true*** for the following:\r\n   *\r\n   *  - 0\r\n   *  - false\r\n   *  - anything else\r\n   *\r\n   * @param {Object} value         value to check\r\n   * @returns {boolean}   true if not empty; false if empty\r\n   */\r\n  var isNotEmpty = exports.isNotEmpty = function(value) {\r\n    return !isEmpty(value);\r\n  };\r\n\r\n  /**\r\n   * Returns ***true*** if the value is defined; otherwise, returns ***false***.\r\n   *\r\n   * Returns ***false*** for the following:\r\n   *\r\n   *  - typeof undefined\r\n   *  - null\r\n   *  - NaN\r\n   *\r\n   * Returns ***true*** for the following:\r\n   *\r\n   *  - 0\r\n   *  - false\r\n   *  - '' (empty string)\r\n   *  - {} (empty object)\r\n   *  - [] (empty array)\r\n   *  - anything else\r\n   *\r\n   * @param {Object} value         value to check\r\n   * @returns {boolean}   true if defined; false if not defined\r\n   */\r\n  var isDefined = exports.isDefined = function(value) {\r\n\r\n    if (typeof value === 'undefined') {\r\n      return false;\r\n    } else if (value === null) {\r\n      return false;\r\n    } else if (isNAN(value)) {\r\n      return false;\r\n    } else if (value === '') {\r\n      return true;\r\n    } else if (value === 0) {\r\n      return true;\r\n    } else if (value === false) {\r\n      return true;\r\n    } else if (isObject(value)) {\r\n      return true;\r\n    } else if (isArray(value)) {\r\n      return true;\r\n    } else {\r\n      return true;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Returns ***true*** if the value is not defined; otherwise, returns ***false***.\r\n   *\r\n   * Returns ***true*** for the following:\r\n   *\r\n   *  - typeof undefined\r\n   *  - null\r\n   *  - NaN\r\n   *\r\n   * Returns ***false*** for the following:\r\n   *\r\n   *  - 0\r\n   *  - false\r\n   *  - '' (empty string)\r\n   *  - {} (empty object)\r\n   *  - [] (empty array)\r\n   *  - anything else\r\n   *\r\n   * @param {Object} value         value to check\r\n   * @returns {boolean}   true if not defined; false if defined\r\n   */\r\n  var isNotDefined = exports.isNotDefined = function(value) {\r\n    return !isDefined(value);\r\n  };\r\n\r\n  /**\r\n   * Returns ***true*** if the value is true, \"true\", \"T\", or 1; otherwise, returns ***false***.\r\n   *\r\n   * Returns ***false*** for the following:\r\n   *\r\n   *  - typeof undefined\r\n   *  - null\r\n   *  - NaN\r\n   *  - 0\r\n   *  - false\r\n   *  - '' (empty string)\r\n   *  - {} (empty object)\r\n   *  - [] (empty array)\r\n   *  - anything else\r\n   *\r\n   * Returns ***true*** for the following:\r\n   *\r\n   *  - true\r\n   *  - \"true\"\r\n   *  - \"T\"\r\n   *  - 1\r\n   *\r\n   * @param {Object} value         value to check\r\n   * @returns {boolean}   true if defined; false if not defined\r\n   */\r\n  var isTrue = exports.isTrue = function(value) {\r\n    if (value === true) {\r\n      return true;\r\n    } else if (value === 1) {\r\n      return true;\r\n    } else if (value && typeof value === \"string\" && value.toLowerCase() === \"true\") {\r\n      return true;\r\n    } else if (value && typeof value === \"string\" &&  value.toLowerCase() === \"t\") {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Returns ***true*** if the value is false, \"false\", \"f\", or 0; otherwise, returns ***false***.\r\n   *\r\n   * Returns ***false*** for the following:\r\n   *\r\n   *  - typeof undefined\r\n   *  - null\r\n   *  - NaN\r\n   *  - '' (empty string)\r\n   *  - {} (empty object)\r\n   *  - [] (empty array)\r\n   *  - true\r\n   *  - 1\r\n   *  - anything else\r\n   *\r\n   *  * Returns ***true*** for the following:\r\n   *\r\n   *  - false\r\n   *  - \"false\"\r\n   *  - \"F\"\r\n   *  - 0\r\n   *\r\n   * @param {Object} value         value to check\r\n   * @returns {boolean}   true if defined; false if not defined\r\n   */\r\n  var isFalse = exports.isFalse = function(value) {\r\n    if (value === false) {\r\n      return true;\r\n    } else if (value === 0) {\r\n      return true;\r\n    } else if (value && typeof value === \"string\" &&  value.toLowerCase() === \"false\") {\r\n      return true;\r\n    } else if (value && typeof value === \"string\" &&  value.toLowerCase() === \"f\") {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Throws an error if the object is not defined (see {@link #isNotDefined} method for definition).\r\n   *\r\n   * @param {String} toAssertName      The name associated with the object.  This name is used when the error is thrown.\r\n   * @param {Object} toAssertObj       The object to assert against\r\n   * @returns {void}\r\n   */\r\n  var assertIsDefined = exports.assertIsDefined = function(toAssertName, toAssertObj){\r\n    if (isNotDefined(toAssertObj)) {\r\n      throw new Error(toAssertName + ' is not defined.');\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Throws an error if the object is defined (see {@link #isDefined} method for definition).\r\n   *\r\n   * @param {String} toAssertName      The name associated with the object.  This name is used when the error is thrown.\r\n   * @param {Object} toAssertObj       The object to assert against\r\n   * @returns {void}\r\n   */\r\n  var assertIsNotDefined = exports.assertIsNotDefined = function(toAssertName, toAssertObj){\r\n    if (isDefined(toAssertObj)) {\r\n      throw new Error(toAssertName + ' is defined.');\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Throws an error if the object is empty (see {@link #isEmpty} method for definition).\r\n   *\r\n   * @param {String} toAssertName      The name associated with the object.  This name is used when the error is thrown.\r\n   * @param {Object} toAssertObj       The object to assert against\r\n   * @returns {void}\r\n   */\r\n  var assertIsNotEmpty = exports.assertIsNotEmpty = function(toAssertName, toAssertObj){\r\n    if (isEmpty(toAssertObj)) {\r\n      throw new Error(toAssertName + ' is empty.');\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Throws an error if the object is not empty (see {@link #isNotEmpty} method for definition).\r\n   *\r\n   * @param {String} toAssertName      The name associated with the object.  This name is used when the error is thrown.\r\n   * @param {Object} toAssertObj       The object to assert against\r\n   * @returns {void}\r\n   */\r\n  var assertIsEmpty = exports.assertIsEmpty = function(toAssertName, toAssertObj){\r\n    if (isNotEmpty(toAssertObj)) {\r\n      throw new Error(toAssertName + ' is not empty.');\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Validates all function inputs are defined.  It will throw an error if any input is not defined\r\n   *\r\n   * @param {Object} fnInputs                     object containing all the function inputs\r\n   * @param {Array} inputsToValidate              a string array of the input names that must be defined in the fnInputs\r\n   * @param {String} functionName                 string identifier of the calling function to output with any error messages\r\n   * @returns {void}\r\n   */\r\n  var validateFunctionInputsAreDefined = exports.validateFunctionInputsAreDefined = function (fnInputs, inputsToValidate, functionName) {\r\n    return validateInputsAreDefined(fnInputs, inputsToValidate, 'fnInputs', functionName);\r\n  };\r\n\r\n  /**\r\n   * Validates all inputs are defined.  It will throw an error if any input is not defined\r\n   *\r\n   * @param {Object} inputs                       object containing all the inputs\r\n   * @param {Array} inputsToValidate              a string array of the input names that must be defined in the inputs\r\n   * @param {String} inputName                    string identifier of the inputs to output with any error messages\r\n   * @param {String} functionName                 string identifier of the calling function to output with any error messages\r\n   * @returns {void}\r\n   */\r\n  var validateInputsAreDefined = exports.validateInputsAreDefined = function (inputs, inputsToValidate, inputName, functionName) {\r\n    functionName = functionName + ' validateInputsAreDefined ';\r\n\r\n    if (isEmpty(inputs)) {\r\n      throw new Error(functionName +  inputName + ' must not be empty');\r\n    }\r\n\r\n    if (!isArray(inputsToValidate)) {\r\n      throw new Error(functionName + 'inputsToValidate must be an array');\r\n    }\r\n\r\n    for (var i=0; i<inputsToValidate.length; i++) {\r\n      var input = inputsToValidate[i];\r\n\r\n      var toTest = getPropertyByString(inputs, input);\r\n\r\n      if (isNotDefined(toTest)) {\r\n        throw new Error(functionName + 'following input must be defined: ' + inputName + '.' + input);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Validates all function inputs are defined.  It will call the callback with an error or 'done' when finished\r\n   *\r\n   * @param {Object} fnInputs                     object containing all the function inputs\r\n   * @param {Array} inputsToValidate       a string array of the input names that must be defined in the fnInputs\r\n   * @param {String} functionName                 string identifier of the calling function to output with any error messages\r\n   * @param {Function} callback                   a callback function\r\n   * @returns {void}\r\n   */\r\n  var validateFunctionInputsAreDefinedAsync = exports.validateFunctionInputsAreDefinedAsync = function (fnInputs, inputsToValidate, functionName, callback) {\r\n\r\n    try {\r\n      validateFunctionInputsAreDefined(fnInputs, inputsToValidate, functionName);\r\n      return callback(null, 'done');\r\n    } catch (err) {\r\n      return callback(err, null);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Validates all function inputs are defined.  It will call the callback only if there is an error.\r\n   *\r\n   * @param {Object} fnInputs                     object containing all the function inputs\r\n   * @param {Array} inputsToValidate       a string array of the input names that must be defined in the fnInputs\r\n   * @param {String} functionName                 string identifier of the calling function to output with any error messages\r\n   * @param {Function} callback                   a callback function\r\n   * @returns {void}\r\n   */\r\n  var validateFunctionInputsAreDefinedCallbackOnError = exports.validateFunctionInputsAreDefinedCallbackOnError = function (fnInputs, inputsToValidate, functionName, callback) {\r\n\r\n    try {\r\n      validateFunctionInputsAreDefined(fnInputs, inputsToValidate, functionName);\r\n      return;\r\n    } catch (err) {\r\n      return callback(err, null);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Validates all inputs are defined.  It will call the callback with an error or 'done' when finished\r\n   *\r\n   * @param {Object} fnInputs                     object containing all the function inputs\r\n   * @param {Array} inputsToValidate       a string array of the input names that must be defined in the fnInputs\r\n   * @param {String} functionName                 string identifier of the calling function to output with any error messages\r\n   * @param {Function} callback                   a callback function\r\n   * @returns {void}\r\n   */\r\n  var validateInputsAreDefinedAsync = exports.validateInputsAreDefinedAsync = function (fnInputs, inputsToValidate, inputName, functionName, callback) {\r\n\r\n    try {\r\n      validateInputsAreDefined(fnInputs, inputsToValidate, inputName, functionName);\r\n      return callback(null, 'done');\r\n    } catch (err) {\r\n      return callback(err, null);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Validates all inputs are defined.  It will call the callback only if there is an error.\r\n   *\r\n   * @param {Object} fnInputs                     object containing all the function inputs\r\n   * @param {Array} inputsToValidate       a string array of the input names that must be defined in the fnInputs\r\n   * @param {String} functionName                 string identifier of the calling function to output with any error messages\r\n   * @param {Function} callback                   a callback function\r\n   * @returns {void}\r\n   */\r\n  var validateInputsAreDefinedCallbackOnError = exports.validateInputsAreDefinedCallbackOnError = function (fnInputs, inputsToValidate, inputName, functionName, callback) {\r\n\r\n    try {\r\n      validateInputsAreDefined(fnInputs, inputsToValidate, inputName, functionName);\r\n      return;\r\n    } catch (err) {\r\n      return callback(err, null);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Validates all function inputs are not empty.  It will throw an error if any input is empty\r\n   *\r\n   * @param {Object} fnInputs                     object containing all the function inputs\r\n   * @param {Array} inputsToValidate              a string array of the input names that must not be empty in the fnInputs\r\n   * @param {String} functionName                 string identifier of the calling function to output with any error messages\r\n   * @returns {void}\r\n   */\r\n  var validateFunctionInputsAreNotEmpty = exports.validateFunctionInputsAreNotEmpty = function (fnInputs, inputsToValidate, functionName) {\r\n    return validateInputsAreNotEmpty(fnInputs, inputsToValidate, 'fnInputs', functionName);\r\n  };\r\n\r\n  /**\r\n   * Validates all inputs are not empty.  It will throw an error if any input is empty\r\n   *\r\n   * @param {Object} inputs                       object containing all the inputs\r\n   * @param {Array} inputsToValidate              a string array of the input names that must not be empty in the inputs\r\n   * @param {String} inputName                    string identifier of the inputs to output with any error messages\r\n   * @param {String} functionName                 string identifier of the calling function to output with any error messages\r\n   * @returns {void}\r\n   */\r\n  var validateInputsAreNotEmpty = exports.validateInputsAreNotEmpty = function (inputs, inputsToValidate, inputName, functionName) {\r\n    functionName = functionName + ' validateInputsAreNotEmpty ';\r\n\r\n    if (isEmpty(inputs)) {\r\n      throw new Error(functionName +  inputName + ' must not be empty');\r\n    }\r\n\r\n    if (!isArray(inputsToValidate)) {\r\n      throw new Error(functionName + 'inputsToValidate must be an array');\r\n    }\r\n\r\n    for (var i=0; i<inputsToValidate.length; i++) {\r\n      var input = inputsToValidate[i];\r\n\r\n      var toTest = getPropertyByString(inputs, input);\r\n\r\n      if (isEmpty(toTest)) {\r\n        throw new Error(functionName + 'following input must not be empty: ' + inputName + '.' + input);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Validates all function inputs are not empty.  It will call the callback with an error or 'done' when finished\r\n   *\r\n   * @param {Object} fnInputs                     object containing all the function inputs\r\n   * @param {Array} inputsToValidate      a string array of the input names that must not be empty in the fnInputs\r\n   * @param {String} functionName                 string identifier of the calling function to output with any error messages\r\n   * @param {Function} callback                   a callback function\r\n   * @returns {void}\r\n   */\r\n  var validateFunctionInputsAreNotEmptyAsync = exports.validateFunctionInputsAreNotEmptyAsync = function (fnInputs, inputsToValidate, functionName, callback) {\r\n\r\n    try {\r\n      validateFunctionInputsAreNotEmpty(fnInputs, inputsToValidate, functionName);\r\n      return callback(null, 'done');\r\n    } catch (err) {\r\n      return callback(err, null);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Validates all function inputs are not empty.  It will call the callback only if there is an error.\r\n   *\r\n   * @param {Object} fnInputs                     object containing all the function inputs\r\n   * @param {Array} inputsToValidate      a string array of the input names that must not be empty in the fnInputs\r\n   * @param {String} functionName                 string identifier of the calling function to output with any error messages\r\n   * @param {Function} callback                   a callback function\r\n   * @returns {void}\r\n   */\r\n  var validateFunctionInputsAreNotEmptyCallbackOnError = exports.validateFunctionInputsAreNotEmptyCallbackOnError = function (fnInputs, inputsToValidate, functionName, callback) {\r\n\r\n    try {\r\n      validateFunctionInputsAreNotEmpty(fnInputs, inputsToValidate, functionName);\r\n      return;\r\n    } catch (err) {\r\n      return callback(err, null);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Validates all inputs are not empty.  It will call the callback with an error or 'done' when finished\r\n   *\r\n   * @param {Object} fnInputs                     object containing all the inputs\r\n   * @param {Array} inputsToValidate              a string array of the input names that must not be empty in the inputs\r\n   * @param {String} inputName                    string identifier of the inputs to output with any error messages\r\n   * @param {String} functionName                 string identifier of the calling function to output with any error messages\r\n   * @param {Function} callback                   a callback function\r\n   * @returns {void}\r\n   */\r\n  var validateInputsAreNotEmptyAsync = exports.validateInputsAreNotEmptyAsync = function (fnInputs, inputsToValidate, inputName, functionName, callback) {\r\n\r\n    try {\r\n      validateInputsAreNotEmpty(fnInputs, inputsToValidate, inputName, functionName);\r\n      return callback(null, 'done');\r\n    } catch (err) {\r\n      return callback(err, null);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Validates all inputs are not empty.  It will call the callback only if there is an error.\r\n   *\r\n   * @param {Object} fnInputs                     object containing all the inputs\r\n   * @param {Array} inputsToValidate              a string array of the input names that must not be empty in the inputs\r\n   * @param {String} inputName                    string identifier of the inputs to output with any error messages\r\n   * @param {String} functionName                 string identifier of the calling function to output with any error messages\r\n   * @param {Function} callback                   a callback function\r\n   * @returns {void}\r\n   */\r\n  var validateInputsAreNotEmptyCallbackOnError = exports.validateInputsAreNotEmptyCallbackOnError = function (fnInputs, inputsToValidate, inputName, functionName, callback) {\r\n\r\n    try {\r\n      validateInputsAreNotEmpty(fnInputs, inputsToValidate, inputName, functionName);\r\n      return;\r\n    } catch (err) {\r\n      return callback(err, null);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Determines if the object is an array or not\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if array; otherwise, false\r\n   */\r\n  var isArray = exports.isArray = function(obj) {\r\n    if (obj && typeof obj === 'object' && typeof obj.length !== 'undefined' && obj.length >= 0) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Determines if the object is not an array or not\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if not array; otherwise, false\r\n   */\r\n  var isNotArray = exports.isNotArray = function(obj) {\r\n    return !isArray(obj);\r\n  };\r\n\r\n\r\n  /**\r\n   * Determines if the object is an empty array or not\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if empty array; otherwise, false\r\n   */\r\n  var isEmptyArray = exports.isEmptyArray = function(obj) {\r\n    if (isArray(obj) && typeof obj.length !== 'undefined' && obj.length === 0) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Determines if the object is a populated array or not\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if populated array; otherwise, false\r\n   */\r\n  var isNotEmptyArray = exports.isNotEmptyArray = function(obj) {\r\n    if (isArray(obj) && typeof obj.length !== 'undefined' && obj.length > 0) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Determines if the object is a NaN or not\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if NaN; otherwise, false\r\n   */\r\n  var isNAN = exports.isNAN = function(obj) {\r\n    // NaN value check\r\n    // ...and yes you need to check that it is a number before checking that it is NotANumber.  Who knew?\r\n    if (typeof obj === 'number' && isNaN(obj)) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Determines if the object is a Date or not\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if Date; otherwise, false\r\n   */\r\n  var isDate = exports.isDate = function(obj) {\r\n    // new Date() is an object, but it has no keys/props so it will fail straight isObject check\r\n    // so if it is a date, it is considered populated\r\n    // also the for loop with the hasOwnProperty did not pass the new Date() either\r\n    // also the _.isEmpty did not pass the new Date() check\r\n    // ...could use _.isDate, but trying to reduce the dependency on external libs\r\n    if (typeof obj === 'object' && Object.prototype.toString.call(obj) === \"[object Date]\") {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Determines if the object is not a Date or not\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if not Date; otherwise, false\r\n   */\r\n  var isNotDate = exports.isNotDate = function(obj) {\r\n    return !isDate(obj);\r\n  };\r\n\r\n  /**\r\n   * Determines if the object is an Error or not\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if Error; otherwise, false\r\n   */\r\n  var isError = exports.isError = function(obj) {\r\n    // new Error() is an object, but it has no keys/props so it will fail straight isObject check\r\n    if (typeof obj === 'object' && Object.prototype.toString.call(obj) === \"[object Error]\") {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Determines if the object is not an Error or not\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if not Error; otherwise, false\r\n   */\r\n  var isNotError = exports.isNotError = function(obj) {\r\n    return !isError(obj);\r\n  };\r\n\r\n  /**\r\n   * Determines if the object is an Object or not.  Note returns false on new Date() and new Error().\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if Object; otherwise, false\r\n   */\r\n  var isObject = exports.isObject = function(obj) {\r\n    // object check\r\n    // this returns false if obj=new Date()\r\n    // this returns false if obj=new Error()\r\n    if (obj && typeof obj === 'object' && isNotArray(obj) && isNotDate(obj) && isNotError(obj)) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Determines if the object is not an Object or not\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if not Object; otherwise, false\r\n   */\r\n  var isNotObject = exports.isNotObject = function(obj) {\r\n    return !isObject(obj);\r\n  };\r\n\r\n  /**\r\n   * Determines if the object is an empty object or not\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if empty object; otherwise, false\r\n   */\r\n  var isEmptyObject = exports.isEmptyObject = function(obj) {\r\n    if (isObject(obj) && Object.keys(obj).length === 0) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Determines if the object is a populated object or not\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if populated object; otherwise, false\r\n   */\r\n  var isNotEmptyObject = exports.isNotEmptyObject = function(obj) {\r\n    if (isObject(obj) && Object.keys(obj).length > 0) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  /*\r\n   * Gets the property based on the string.\r\n   * So if the obj={foo:{bar:{blah:\"here\"}}}, getPropertyByString(obj, \"foo.bar.blah\") would return \"here\"\r\n   * There cannot be any \".\" in any of the property names for this to work correctly\r\n   * see http://stackoverflow.com/questions/6906108/in-javascript-how-can-i-dynamically-get-a-nested-property-of-an-object\r\n   *\r\n   * @param {Object} obj                      object to be search\r\n   * @param {String} propString               name of the property to find; use \".\" to indicate parent/child elements\r\n   * @returns {Object}                        returns the property value\r\n   */\r\n  var getPropertyByString = exports.getPropertyByString = function(obj, propString) {\r\n    if (isEmpty(propString)) {return obj;}\r\n\r\n    var prop;\r\n    var props = propString.split('.');\r\n\r\n    var propLength = props.length - 1;\r\n    var i=0;\r\n    for (i=0; i < propLength; i++) {\r\n      prop = props[i];\r\n\r\n      if (typeof obj === 'object' && obj !== null && prop in obj) {\r\n        obj = obj[prop];\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n    return obj[props[i]];\r\n  };\r\n\r\n  /*\r\n   * Sets the property based on the string.\r\n   * So if the obj={foo:{bar:{blah:\"here\"}}}, setPropertyByString(obj, \"foo.bar.blah\", \"newHere\") would replace \"here\" with \"newHere\"\r\n   * There cannot be any \".\" in any of the property names for this to work correctly\r\n   * see http://stackoverflow.com/questions/6906108/in-javascript-how-can-i-dynamically-get-a-nested-property-of-an-object\r\n   *\r\n   * @param {Object} obj                      object to be search\r\n   * @param {String} propString               name of the property to find; use \".\" to indicate parent/child elements\r\n   * @param {Object} newValue                 the property value to set\r\n   */\r\n  var setPropertyByString =  exports.setPropertyByString = function(obj, propString, newValue) {\r\n    if (isEmpty(propString)) {return obj;}\r\n\r\n    var prop;\r\n    var props = propString.split('.');\r\n\r\n    var propLength = props.length - 1;\r\n\r\n    if (propLength === 0) {\r\n      obj[propString] = newValue;\r\n    } else {\r\n      var lookupObj = obj;\r\n      for (var i=0; i <= propLength - 1; i++) {\r\n        prop = props[i];\r\n\r\n        if (typeof obj === 'object' && obj !== null && prop in obj) {\r\n          obj = obj[prop];\r\n        } else {\r\n          obj[prop] = {};\r\n          obj = obj[prop];\r\n        }\r\n      }\r\n\r\n      // then on last prop in propString\r\n      prop = props[i];\r\n      if (typeof obj === 'object' && obj !== null) {\r\n        obj[prop] = newValue;\r\n      } else {\r\n        // do not update anything since the obj doesn't exist\r\n      }\r\n    }\r\n    return;\r\n  };\r\n\r\n  var assertNestedListIsDefined =  exports.assertNestedListIsDefined = function(list) {\r\n    if (isNotArray(list)) {return false;}\r\n\r\n    list.forEach(function(item) {\r\n      assertNestedIsDefined.apply(null, item);\r\n    });\r\n\r\n    return true;\r\n  };\r\n\r\n  var assertNestedIsDefined =  exports.assertNestedIsDefined = function(obj, toAssertName) {\r\n    var args = Array.prototype.slice.call(arguments, 2);\r\n    for (var i = 0; i < args.length; i++) {\r\n      if (!obj) {\r\n        throw new Error(toAssertName + ' is not defined.');\r\n      }\r\n      if (!obj.hasOwnProperty(args[i]) || isNotDefined(obj[args[i]])) {\r\n        throw new Error(toAssertName + '.' + args[i] + ' is not defined.');\r\n      }\r\n      obj = obj[args[i]];\r\n      toAssertName = toAssertName + '.' + args[i];\r\n    }\r\n    return true;\r\n  };\r\n\r\n})( false? undefined: exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/simple-js-validator/lib/simple.js.validator.js?");

/***/ }),

/***/ "./node_modules/style-loader/addStyles.js":
/*!************************************************!*\
  !*** ./node_modules/style-loader/addStyles.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nvar stylesInDom = {},\r\n\tmemoize = function(fn) {\r\n\t\tvar memo;\r\n\t\treturn function () {\r\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\treturn memo;\r\n\t\t};\r\n\t},\r\n\tisOldIE = memoize(function() {\r\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t}),\r\n\tgetHeadElement = memoize(function () {\r\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t}),\r\n\tsingletonElement = null,\r\n\tsingletonCounter = 0;\r\n\r\nmodule.exports = function(list, options) {\r\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\r\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t}\r\n\r\n\toptions = options || {};\r\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t// tags it will allow on a page\r\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\r\n\tvar styles = listToStyles(list);\r\n\taddStylesToDom(styles, options);\r\n\r\n\treturn function update(newList) {\r\n\t\tvar mayRemove = [];\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tdomStyle.refs--;\r\n\t\t\tmayRemove.push(domStyle);\r\n\t\t}\r\n\t\tif(newList) {\r\n\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\taddStylesToDom(newStyles, options);\r\n\t\t}\r\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction addStylesToDom(styles, options) {\r\n\tfor(var i = 0; i < styles.length; i++) {\r\n\t\tvar item = styles[i];\r\n\t\tvar domStyle = stylesInDom[item.id];\r\n\t\tif(domStyle) {\r\n\t\t\tdomStyle.refs++;\r\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t}\r\n\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar parts = [];\r\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction listToStyles(list) {\r\n\tvar styles = [];\r\n\tvar newStyles = {};\r\n\tfor(var i = 0; i < list.length; i++) {\r\n\t\tvar item = list[i];\r\n\t\tvar id = item[0];\r\n\t\tvar css = item[1];\r\n\t\tvar media = item[2];\r\n\t\tvar sourceMap = item[3];\r\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\tif(!newStyles[id])\r\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\telse\r\n\t\t\tnewStyles[id].parts.push(part);\r\n\t}\r\n\treturn styles;\r\n}\r\n\r\nfunction createStyleElement() {\r\n\tvar styleElement = document.createElement(\"style\");\r\n\tvar head = getHeadElement();\r\n\tstyleElement.type = \"text/css\";\r\n\thead.appendChild(styleElement);\r\n\treturn styleElement;\r\n}\r\n\r\nfunction createLinkElement() {\r\n\tvar linkElement = document.createElement(\"link\");\r\n\tvar head = getHeadElement();\r\n\tlinkElement.rel = \"stylesheet\";\r\n\thead.appendChild(linkElement);\r\n\treturn linkElement;\r\n}\r\n\r\nfunction addStyle(obj, options) {\r\n\tvar styleElement, update, remove;\r\n\r\n\tif (options.singleton) {\r\n\t\tvar styleIndex = singletonCounter++;\r\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement());\r\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t} else if(obj.sourceMap &&\r\n\t\ttypeof URL === \"function\" &&\r\n\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\ttypeof Blob === \"function\" &&\r\n\t\ttypeof btoa === \"function\") {\r\n\t\tstyleElement = createLinkElement();\r\n\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\t\tif(styleElement.href)\r\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t};\r\n\t} else {\r\n\t\tstyleElement = createStyleElement();\r\n\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\t};\r\n\t}\r\n\r\n\tupdate(obj);\r\n\r\n\treturn function updateStyle(newObj) {\r\n\t\tif(newObj) {\r\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\treturn;\r\n\t\t\tupdate(obj = newObj);\r\n\t\t} else {\r\n\t\t\tremove();\r\n\t\t}\r\n\t};\r\n}\r\n\r\nvar replaceText = (function () {\r\n\tvar textStore = [];\r\n\r\n\treturn function (index, replacement) {\r\n\t\ttextStore[index] = replacement;\r\n\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t};\r\n})();\r\n\r\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\tvar css = remove ? \"\" : obj.css;\r\n\r\n\tif (styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t} else {\r\n\t\tvar cssNode = document.createTextNode(css);\r\n\t\tvar childNodes = styleElement.childNodes;\r\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\tif (childNodes.length) {\r\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t} else {\r\n\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction applyToTag(styleElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(media) {\r\n\t\tstyleElement.setAttribute(\"media\", media)\r\n\t}\r\n\r\n\tif(styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = css;\r\n\t} else {\r\n\t\twhile(styleElement.firstChild) {\r\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t}\r\n\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t}\r\n}\r\n\r\nfunction updateLink(linkElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(sourceMap) {\r\n\t\t// http://stackoverflow.com/a/26603875\r\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t}\r\n\r\n\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\r\n\tvar oldSrc = linkElement.href;\r\n\r\n\tlinkElement.href = URL.createObjectURL(blob);\r\n\r\n\tif(oldSrc)\r\n\t\tURL.revokeObjectURL(oldSrc);\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/style-loader/addStyles.js?");

/***/ }),

/***/ "./src/Map.js":
/*!********************!*\
  !*** ./src/Map.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n__webpack_require__(/*! ./style.css */ \"./src/style.css\");\n\nvar objectAssign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\n\nvar dom = __webpack_require__(/*! ./utils/dom */ \"./src/utils/dom.js\");\n\nvar Map =\n/*#__PURE__*/\nfunction () {\n  function Map(domSelector, apiKey, locale, options, plugins, customWindow) {\n    _classCallCheck(this, Map);\n\n    this.domElement = dom.isHTMLElement(domSelector) ? domSelector : document.querySelector(domSelector);\n    this.domId = this.domElement.id || '';\n    this.apiKey = apiKey;\n    this.locale = locale || 'en';\n    this.setOptions(options);\n    this.plugins = plugins || {};\n    this.provider = '[No provider defined]';\n    this.window = customWindow || window;\n  }\n\n  _createClass(Map, [{\n    key: \"setPoints\",\n    value: function setPoints(points) {\n      if (Object.prototype.toString.call(points) === '[object Array]') {\n        this.points = points;\n      } else {\n        this.points = [points];\n      }\n    }\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      var defaultOptions = {\n        map: {},\n        marker: {},\n        markerCluster: {},\n        infoWindow: {},\n        loadParams: {}\n      };\n      this.options = objectAssign(defaultOptions, options);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      console.error(this.provider + ' has no render method implemented');\n    }\n  }, {\n    key: \"load\",\n    value: function load() {\n      console.error(this.provider + ' has no load method implemented');\n    }\n  }, {\n    key: \"setBounds\",\n    value: function setBounds() {\n      console.error(this.provider + ' has no setBounds method implemented');\n    }\n  }, {\n    key: \"setIconOnMarker\",\n    value: function setIconOnMarker() {\n      console.error(this.provider + ' has no setIconOnMarker method implemented');\n    }\n  }, {\n    key: \"focusOnMarker\",\n    value: function focusOnMarker() {\n      console.error(this.provider + ' has no focusOnMarker method implemented');\n    }\n  }, {\n    key: \"clickOnMarker\",\n    value: function clickOnMarker() {\n      console.error(this.provider + ' has no clickOnMarker method implemented');\n    }\n  }, {\n    key: \"getDirections\",\n    value: function getDirections() {\n      console.error(this.provider + ' has no getDirections method implemented');\n    }\n  }, {\n    key: \"setCenter\",\n    value: function setCenter() {\n      console.error(this.provider + ' has no setCenter method implemented');\n    }\n  }, {\n    key: \"setZoom\",\n    value: function setZoom() {\n      console.error(this.provider + ' has no setZoom method implemented');\n    }\n  }, {\n    key: \"addMarkers\",\n    value: function addMarkers() {\n      console.error(this.provider + ' has no addMarkers method implemented');\n    }\n  }]);\n\n  return Map;\n}();\n\nmodule.exports = Map;\n\n//# sourceURL=webpack:///./src/Map.js?");

/***/ }),

/***/ "./src/providers/googleMap/DirectionsService.js":
/*!******************************************************!*\
  !*** ./src/providers/googleMap/DirectionsService.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar objectAssign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\n\nvar DirectionsService =\n/*#__PURE__*/\nfunction (_google$maps$Directio) {\n  _inherits(DirectionsService, _google$maps$Directio);\n\n  function DirectionsService(map, panelSelector) {\n    var _this;\n\n    _classCallCheck(this, DirectionsService);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DirectionsService).call(this));\n    _this.display = new google.maps.DirectionsRenderer();\n\n    _this.display.setMap(map);\n\n    if (panelSelector) {\n      var panel = document.querySelector(panelSelector);\n      panel.innerHTML = '';\n\n      _this.display.setPanel(panel);\n    }\n\n    return _this;\n  }\n\n  _createClass(DirectionsService, [{\n    key: \"getRoute\",\n    value: function getRoute(origin, destination, options, callback, onError) {\n      var _this2 = this;\n\n      callback = callback || function () {};\n\n      this.route(buildRequest(origin, destination, options), function (result, status) {\n        if (status === google.maps.DirectionsStatus.OK) {\n          _this2.display.setDirections(result);\n\n          callback(result.routes[0]);\n        } else {\n          onError('Unable to calculate a driving itinerary for the destination: ' + destination);\n        }\n      });\n    }\n  }]);\n\n  return DirectionsService;\n}(google.maps.DirectionsService);\n\nmodule.exports = DirectionsService;\n\nfunction buildRequest(origin, destination, options) {\n  return objectAssign({\n    travelMode: google.maps.TravelMode.DRIVING\n  }, options || {}, {\n    origin: origin,\n    destination: options.region ? options.region + ' ' + destination : destination\n  });\n}\n\n//# sourceURL=webpack:///./src/providers/googleMap/DirectionsService.js?");

/***/ }),

/***/ "./src/providers/googleMap/GoogleMap.js":
/*!**********************************************!*\
  !*** ./src/providers/googleMap/GoogleMap.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Google Map v3\n * API Documentation: https://developers.google.com/maps/documentation/javascript/\n */\n\n/*jshint -W079 */\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar Map = __webpack_require__(/*! ../../Map */ \"./src/Map.js\");\n/* jshint +W079 */\n\n\nvar domUtils = __webpack_require__(/*! ../../utils/dom */ \"./src/utils/dom.js\");\n\nvar ieUtils = __webpack_require__(/*! ../../utils/ie */ \"./src/utils/ie.js\");\n\nvar loaderUtils = __webpack_require__(/*! ../../utils/loader */ \"./src/utils/loader.js\");\n\nvar objectAssign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\n\nvar InfoWindow;\nvar Marker;\n\nvar GoogleMap =\n/*#__PURE__*/\nfunction (_Map) {\n  _inherits(GoogleMap, _Map);\n\n  function GoogleMap() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, GoogleMap);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(GoogleMap)).call.apply(_getPrototypeOf2, [this].concat(args)));\n    _this.provider = 'Google';\n    _this.map = null;\n    _this.markers = [];\n    _this.infoWindow = null;\n    _this.markerClusterers = [];\n    return _this;\n  }\n\n  _createClass(GoogleMap, [{\n    key: \"render\",\n    value: function render(callback) {\n      var _this2 = this;\n\n      if (this.plugins.infobox) {\n        InfoWindow = __webpack_require__(/*! ./plugins/InfoBox */ \"./src/providers/googleMap/plugins/InfoBox.js\");\n      } else {\n        InfoWindow = __webpack_require__(/*! ./InfoWindow */ \"./src/providers/googleMap/InfoWindow.js\");\n      } // Init the map\n\n\n      this.map = new google.maps.Map(this.domElement, this.options.map);\n      this.markers = [];\n      this.markerClusterers = []; // Init the info window is the option is set\n\n      if (this.options.activeInfoWindow) {\n        this.infoWindow = new InfoWindow(this.options.infoWindow);\n      }\n\n      if (this.options.map.zoom) {\n        // This is needed to set the zoom after fitBounds,\n        google.maps.event.addListenerOnce(this.map, 'bounds_changed', function () {\n          _this2.map.setZoom(Math.min(_this2.options.map.zoom, _this2.map.getZoom()));\n        });\n      } // Create a marker for each point\n\n\n      this.addMarkers(this.points, 0); // Center the map\n\n      this.setBounds();\n\n      if (callback) {\n        callback();\n      }\n    }\n  }, {\n    key: \"load\",\n    value: function load(callback, loadingMask) {\n      var _this3 = this;\n\n      if (window.google && window.google.maps) {\n        callback();\n        return;\n      }\n\n      var domElement = this.domElement;\n      var plugins = this.plugins;\n\n      this.window._googleMapCallbackOnLoad = function () {\n        window.google = this.window.google; // Require google object here cause they're not loaded before\n\n        Marker = __webpack_require__(/*! ./Marker */ \"./src/providers/googleMap/Marker.js\");\n        ieUtils.delete(this.window, '_googleMapCallbackOnLoad');\n        var resources = [];\n\n        if (plugins.clusterer) {\n          resources.push(domUtils.createScript('//d11lbkprc85eyb.cloudfront.net/markerclusterer.min.js'));\n        }\n\n        if (plugins.infobox) {\n          resources.push(domUtils.createScript('//d11lbkprc85eyb.cloudfront.net/plugins/googleMap/infobubble-compiled.js'));\n        }\n\n        domUtils.addResources(domElement, resources, callback);\n      };\n\n      if (loadingMask) {\n        callback = loaderUtils.addLoader(this.domElement, loadingMask, callback);\n      }\n\n      var urlParams = Object.keys(this.options.loadParams).reduce(function (param, key) {\n        param += key + '=' + _this3.options.loadParams[key] + '&';\n        return param;\n      }, '?');\n      urlParams += 'v=3.31&callback=_googleMapCallbackOnLoad&language=' + this.locale;\n\n      if (!this.options.loadParams.signature) {\n        urlParams += '&key=' + this.apiKey;\n      }\n\n      domUtils.addScript(this.domElement, '//maps.googleapis.com/maps/api/js' + urlParams);\n    }\n  }, {\n    key: \"setBounds\",\n    value: function setBounds() {\n      var bounds = new google.maps.LatLngBounds();\n      this.markers.forEach(function (marker) {\n        bounds.extend(marker.position);\n      });\n      this.map.fitBounds(bounds);\n    }\n  }, {\n    key: \"setIconOnMarker\",\n    value: function setIconOnMarker(markerId, icon) {\n      markerId = markerId.toString();\n      var marker = this.markers.filter(function (marker) {\n        return marker.id.toString() === markerId;\n      });\n\n      if (marker.length && icon) {\n        marker[0].setIcon(icon);\n      }\n    }\n  }, {\n    key: \"clickOnMarker\",\n    value: function clickOnMarker(markerId) {\n      this.focusOnMarker(markerId, true, true, 0);\n    }\n  }, {\n    key: \"focusOnMarker\",\n    value: function focusOnMarker(markerId) {\n      var showInfoWindow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var pan = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var zoom = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      markerId = markerId.toString();\n      var marker = this.markers.filter(function (marker) {\n        return marker.id.toString() === markerId;\n      });\n\n      if (marker.length) {\n        if (pan) {\n          // If the marker is inside a cluster, we have to zoom to it before triggering the click\n          if (this.options.activeCluster && !marker[0].getMap()) {\n            this.map.setZoom(17);\n          } else if (zoom > 0) {\n            this.setZoom(zoom);\n          }\n\n          if (showInfoWindow && this.infoWindow) {\n            google.maps.event.trigger(marker[0], 'click');\n          } else {\n            // The pan is managed by the infowindow\n            this.map.panTo(marker[0].position);\n          }\n        } else if (showInfoWindow) {\n          google.maps.event.trigger(marker[0], 'click');\n        }\n      }\n    }\n  }, {\n    key: \"getDirections\",\n    value: function getDirections(origin, destination, options, callback, onError) {\n      var DirectionsService = __webpack_require__(/*! ./DirectionsService */ \"./src/providers/googleMap/DirectionsService.js\");\n\n      var map = new google.maps.Map(this.domElement, this.options.map);\n      var directionsService = new DirectionsService(map, options.panelSelector);\n      delete options.panelSelector;\n      directionsService.getRoute(origin, destination, options, callback, onError);\n    }\n  }, {\n    key: \"setCenter\",\n    value: function setCenter(lat, lng) {\n      if (this.map) {\n        this.map.setCenter({\n          lat: lat,\n          lng: lng\n        });\n      }\n    }\n  }, {\n    key: \"setZoom\",\n    value: function setZoom(level) {\n      if (this.map) {\n        this.map.setZoom(level);\n      }\n    }\n  }, {\n    key: \"addMarkers\",\n    value: function addMarkers(points) {\n      var _this4 = this;\n\n      var clusterIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var clusterConfig = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n      if (Object.prototype.toString.call(points) !== '[object Array]') {\n        points = [points];\n      }\n\n      if (!clusterConfig) {\n        clusterConfig = this.options.markerCluster;\n      }\n\n      var markers = [];\n      var options = {};\n\n      var _loop = function _loop(i) {\n        options = objectAssign({}, _this4.options.marker, points[i].options ? points[i].options : {});\n\n        if (typeof options.activeInfoWindow === 'undefined' || options.activeInfoWindow === null) {\n          options.activeInfoWindow = _this4.options.activeInfoWindow;\n        }\n\n        if (typeof options.activeCluster === 'undefined' || options.activeCluster === null) {\n          options.activeCluster = _this4.options.activeCluster;\n        }\n\n        points[i].options = options;\n        var marker = new Marker(_this4.map, points[i], options); // Bind the info window on marker click if the option is set\n\n        if (options.activeInfoWindow) {\n          google.maps.event.addListener(marker, 'click', function () {\n            _this4.infoWindow.open(points[i].data, _this4.map, marker);\n          });\n        } else {\n          google.maps.event.addListener(marker, 'click', function () {\n            _this4.map.panTo(marker.getPosition());\n          });\n        }\n\n        markers.push(marker);\n\n        _this4.markers.push(marker);\n      };\n\n      for (var i = 0; i < points.length; i++) {\n        _loop(i);\n      } // If clustering is activated for those markers\n\n\n      if (this.map && this.plugins.clusterer && this.options.activeCluster && clusterIndex !== null) {\n        if (this.markerClusterers[clusterIndex]) {\n          for (var i = 0; i < markers.length; i++) {\n            this.markerClusterers[clusterIndex].addMarker(markers[i]);\n          }\n        } else {\n          var markerClusterer = new this.window.MarkerClusterer(this.map, markers, clusterConfig);\n          this.markerClusterers.push(markerClusterer);\n        }\n      }\n\n      return markers;\n    }\n  }]);\n\n  return GoogleMap;\n}(Map);\n\nwindow.Map = GoogleMap;\nwindow.OneMap = GoogleMap;\n\n//# sourceURL=webpack:///./src/providers/googleMap/GoogleMap.js?");

/***/ }),

/***/ "./src/providers/googleMap/InfoWindow.js":
/*!***********************************************!*\
  !*** ./src/providers/googleMap/InfoWindow.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nvar objectAssign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\n\nvar InfoWindow =\n/*#__PURE__*/\nfunction (_google$maps$InfoWind) {\n  _inherits(InfoWindow, _google$maps$InfoWind);\n\n  function InfoWindow(options) {\n    var _this;\n\n    _classCallCheck(this, InfoWindow);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(InfoWindow).call(this, objectAssign({}, options, {\n      content: ''\n    })));\n    _this._content = options.content;\n\n    if (options.onDomReady) {\n      google.maps.event.addListener(_assertThisInitialized(_assertThisInitialized(_this)), 'domready', options.onDomReady);\n    }\n\n    return _this;\n  }\n\n  _createClass(InfoWindow, [{\n    key: \"build\",\n    value: function build(data) {\n      if (typeof this._content === 'string') {\n        return this._content;\n      }\n\n      if (typeof this._content === 'function') {\n        return this._content(data);\n      }\n\n      console.error('Info Window content must be a string or a function that return a string');\n    }\n  }, {\n    key: \"open\",\n    value: function open(data) {\n      var _get2;\n\n      _get(_getPrototypeOf(InfoWindow.prototype), \"setContent\", this).call(this, this.build(data));\n\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      (_get2 = _get(_getPrototypeOf(InfoWindow.prototype), \"open\", this)).call.apply(_get2, [this].concat(args));\n    }\n  }]);\n\n  return InfoWindow;\n}(google.maps.InfoWindow);\n\nmodule.exports = InfoWindow;\n\n//# sourceURL=webpack:///./src/providers/googleMap/InfoWindow.js?");

/***/ }),

/***/ "./src/providers/googleMap/Marker.js":
/*!*******************************************!*\
  !*** ./src/providers/googleMap/Marker.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar isDefined = __webpack_require__(/*! simple-js-validator */ \"./node_modules/simple-js-validator/lib/simple.js.validator.js\").isDefined;\n\nvar isTrue = __webpack_require__(/*! simple-js-validator */ \"./node_modules/simple-js-validator/lib/simple.js.validator.js\").isTrue;\n\nvar isAFunction = __webpack_require__(/*! ../../utils/type */ \"./src/utils/type.js\").isAFunction;\n\nvar isAString = __webpack_require__(/*! ../../utils/type */ \"./src/utils/type.js\").isAString;\n\nvar objectAssign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\n\nvar MarkerWithLabel = __webpack_require__(/*! @google/markerwithlabel */ \"./node_modules/@google/markerwithlabel/src/markerwithlabel.js\");\n\nvar dom = __webpack_require__(/*! ../../utils/dom */ \"./src/utils/dom.js\");\n\nvar DEFAULT_MARKER_LABEL_CSS_CLASS = 'lf-map-marker-label';\n\nvar Marker =\n/*#__PURE__*/\nfunction (_MarkerWithLabel) {\n  _inherits(Marker, _MarkerWithLabel);\n\n  function Marker(map, point, options) {\n    var _this;\n\n    _classCallCheck(this, Marker);\n\n    var markerOptions = buildMarkerOptions(point, map, options);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Marker).call(this, markerOptions));\n    _this.id = point.id;\n\n    _this.defineLabel(options);\n\n    _this.addOnDragEndEventListener(markerOptions, options);\n\n    return _this;\n  }\n\n  _createClass(Marker, [{\n    key: \"defineLabel\",\n    value: function defineLabel(options) {\n      // if possible use the native type defined in google maps api\n      // @see https://developers.google.com/maps/documentation/javascript/reference/marker#MarkerLabel\n      if (true === isAMarkerLabel(options.label)) {\n        this.setLabel(options.label);\n      }\n    }\n  }, {\n    key: \"addOnDragEndEventListener\",\n    value: function addOnDragEndEventListener(marker, options) {\n      if (true === isTrue(marker.draggable) && true === isDefined(options.onDragEnd)) {\n        google.maps.event.addListener(this, 'dragend', function (event) {\n          options.onDragEnd(event.latLng.lat(), event.latLng.lng());\n        });\n      }\n    }\n  }]);\n\n  return Marker;\n}(MarkerWithLabel);\n\nfunction buildMarkerOptions(point, map, options) {\n  var markerOptions = {\n    position: new google.maps.LatLng(point.latitude, point.longitude),\n    map: map,\n    draggable: options.draggable || false\n  };\n\n  if (true === isDefined(options.icon)) {\n    var iconOptions = objectAssign({}, options.icon);\n    objectAssign(markerOptions, {\n      icon: iconOptions\n    });\n  } // NOTE:\n  // this is a HACK to preserve backward compatibility.\n  // There is an implicit contract here: the css class for the label is inside an html fragment\n  // given in options.label.\n  // We should be more explicit: options.label should contain only the actual text to display\n  // and we should add an options.labelCssClass field\n\n\n  var textAndCssForLabel = getTextAndCssForLabel(options.label, point);\n\n  if (true === isDefined(textAndCssForLabel)) {\n    objectAssign(markerOptions, {\n      labelContent: textAndCssForLabel.textContent\n    });\n\n    if (true === isAString(textAndCssForLabel.classes) && textAndCssForLabel.classes.trim().length > 0) {\n      var labelClass = textAndCssForLabel.classes;\n      objectAssign(markerOptions, {\n        labelClass: labelClass\n      });\n      var style = dom.getStyleFromCss(labelClass);\n      objectAssign(markerOptions, {\n        labelAnchor: new google.maps.Point(-style.left + 1, -style.top)\n      });\n    }\n  }\n\n  if (false === isDefined(markerOptions.labelClass)) {\n    objectAssign(markerOptions, {\n      labelClass: DEFAULT_MARKER_LABEL_CSS_CLASS\n    });\n  }\n\n  return markerOptions;\n}\n\nfunction getTextAndCssForLabel(label, point) {\n  var result = null;\n\n  if (true === isDefined(label)) {\n    var labelValue = getLabelValue(label, point);\n\n    if (true === isAString(labelValue)) {\n      result = dom.extractTextAndCssClasses(labelValue);\n    }\n  }\n\n  return result;\n}\n\nfunction getLabelValue(label, point) {\n  if (true === isAFunction(label)) {\n    return label(point);\n  } else {\n    return label;\n  }\n}\n\nfunction isAMarkerLabel(label) {\n  // use duck typing heuristic\n  return true === isDefined(label) && (true === isDefined(label.color) || true === isDefined(label.fontFamily) || true === isDefined(label.fontSize) || true === isDefined(label.fontWeight) || true === isDefined(label.text));\n}\n\nmodule.exports = Marker;\n\n//# sourceURL=webpack:///./src/providers/googleMap/Marker.js?");

/***/ }),

/***/ "./src/providers/googleMap/plugins/InfoBox.js":
/*!****************************************************!*\
  !*** ./src/providers/googleMap/plugins/InfoBox.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar objectAssign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\n/* global InfoBubble:true */\n\n\nvar InfoBoxPlugin =\n/*#__PURE__*/\nfunction () {\n  function InfoBoxPlugin(options) {\n    _classCallCheck(this, InfoBoxPlugin);\n\n    var infoBox = new InfoBubble(objectAssign({}, options, {\n      content: ''\n    }));\n    this._content = options.content;\n    this.box = infoBox;\n\n    if (options.onDomReady) {\n      google.maps.event.addListener(this.box, 'domready', options.onDomReady);\n    }\n  }\n\n  _createClass(InfoBoxPlugin, [{\n    key: \"build\",\n    value: function build(data) {\n      if (typeof this._content === 'string') {\n        return this._content;\n      }\n\n      if (typeof this._content === 'function') {\n        return this._content(data);\n      }\n\n      console.error('Info Box content must be a string or a function that return a string');\n    }\n  }, {\n    key: \"open\",\n    value: function open(data) {\n      var _this$box;\n\n      this.box.setContent(this.build(data));\n\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      (_this$box = this.box).open.apply(_this$box, args);\n    }\n  }]);\n\n  return InfoBoxPlugin;\n}();\n\nmodule.exports = InfoBoxPlugin;\n\n//# sourceURL=webpack:///./src/providers/googleMap/plugins/InfoBox.js?");

/***/ }),

/***/ "./src/style.css":
/*!***********************!*\
  !*** ./src/style.css ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(/*! !../node_modules/css-loader!./style.css */ \"./node_modules/css-loader/index.js!./src/style.css\");\nif(typeof content === 'string') content = [[module.i, content, '']];\n// add the styles to the DOM\nvar update = __webpack_require__(/*! ../node_modules/style-loader/addStyles.js */ \"./node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {}\n\n//# sourceURL=webpack:///./src/style.css?");

/***/ }),

/***/ "./src/utils/dom.js":
/*!**************************!*\
  !*** ./src/utils/dom.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar ieUtils = __webpack_require__(/*! ./ie */ \"./src/utils/ie.js\");\n\nvar isAString = __webpack_require__(/*! ./type */ \"./src/utils/type.js\").isAString;\n\nvar isDefined = __webpack_require__(/*! simple-js-validator */ \"./node_modules/simple-js-validator/lib/simple.js.validator.js\").isDefined;\n\nmodule.exports = {\n  addScript: function addScript(domElement, src) {\n    domElement.appendChild(this.createScript(src));\n  },\n  addStyle: function addStyle(domElement, href) {\n    domElement.appendChild(this.createStyle(href));\n  },\n  addResources: function addResources(domElement, resources, callback) {\n    var nbLoaded = 0;\n\n    if (resources.length === 0) {\n      callback();\n    }\n\n    resources.forEach(function (resource) {\n      ieUtils.addLoadListener(resource, function () {\n        nbLoaded++;\n\n        if (nbLoaded === resources.length) {\n          callback();\n        }\n      });\n      domElement.appendChild(resource);\n    });\n  },\n  createScript: function createScript(src) {\n    var script = document.createElement('script');\n    script.type = 'text/javascript';\n    script.src = src;\n    script.async = true;\n    return script;\n  },\n  createStyle: function createStyle(href) {\n    var style = document.createElement('link');\n    style.rel = 'stylesheet';\n    style.href = href;\n    return style;\n  },\n  isHTMLElement: function isHTMLElement(obj) {\n    return obj && _typeof(obj) === 'object' && obj !== null && obj.nodeType === 1 && typeof obj.nodeName === 'string';\n  },\n  extractTextAndCssClasses: function extractTextAndCssClasses(str) {\n    var div = document.createElement('div');\n    div.innerHTML = str;\n    var textContent = div.textContent || div.innerText || '';\n    var classes = '';\n\n    if (isDefined(div.firstChild)) {\n      classes = div.firstChild.className;\n    }\n\n    return {\n      textContent: textContent,\n      classes: classes\n    };\n  },\n  // use a memoized version of the function as il would be silly to repeat the operation\n  getStyleFromCss: memoize(function (cssClass) {\n    var div = document.createElement('div');\n    div.className = cssClass;\n    document.body.appendChild(div);\n    var style = window.getComputedStyle(div);\n    var result = {\n      top: extractPx(style.top),\n      left: extractPx(style.left)\n    };\n    document.body.removeChild(div);\n    return result;\n  })\n};\n\nfunction extractPx(str) {\n  if (true === isAString(str)) {\n    var pxValue = str.replace('px', '').replace('\"', '');\n    var pxNumber = Number.parseInt(pxValue);\n    return Number.isFinite(pxNumber) ? pxNumber : 0;\n  } else {\n    return 0;\n  }\n}\n\nfunction memoize(func) {\n  var cache = {};\n  return function (arg) {\n    if (arg in cache) {\n      return cache[arg];\n    } else {\n      try {\n        var result = func(arg);\n        cache[arg] = result;\n        return result;\n      } catch (e) {\n        console.log(e);\n        return null;\n      }\n    }\n  };\n}\n\n//# sourceURL=webpack:///./src/utils/dom.js?");

/***/ }),

/***/ "./src/utils/ie.js":
/*!*************************!*\
  !*** ./src/utils/ie.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = {\n  delete: function _delete(obj, key) {\n    try {\n      delete obj[key];\n    } catch (e) {\n      obj[key] = undefined;\n    }\n  },\n  addEventListener: function addEventListener(domElement, event, callback, useCapture) {\n    if (domElement.addEventListener) {\n      domElement.addEventListener(event, callback, useCapture);\n    } else {\n      domElement.attachEvent('on' + event, callback);\n    }\n  },\n  addLoadListener: function addLoadListener(resource, callback) {\n    resource.onreadystatechange = function () {\n      if (this.readyState === 'complete') {\n        callback();\n      }\n    };\n\n    resource.onload = callback;\n  }\n};\n\n//# sourceURL=webpack:///./src/utils/ie.js?");

/***/ }),

/***/ "./src/utils/loader.js":
/*!*****************************!*\
  !*** ./src/utils/loader.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar defaultLoaderClass = 'one-map-to-rule-them-all__spinner';\nmodule.exports = {\n  addLoader: function addLoader(domElement, loadingMask, callbackToWrap) {\n    var loader = document.createElement('div');\n\n    if (typeof loadingMask === 'string') {\n      loader.className = loadingMask;\n    } else {\n      loader.className = defaultLoaderClass;\n    }\n\n    domElement.appendChild(loader);\n    return function () {\n      domElement.removeChild(loader);\n      callbackToWrap();\n    };\n  }\n};\n\n//# sourceURL=webpack:///./src/utils/loader.js?");

/***/ }),

/***/ "./src/utils/type.js":
/*!***************************!*\
  !*** ./src/utils/type.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction isAString(something) {\n  return typeof something === 'string';\n}\n\nfunction isAFunction(something) {\n  return typeof something === 'function';\n}\n\nmodule.exports = {\n  isAString: isAString,\n  isAFunction: isAFunction\n};\n\n//# sourceURL=webpack:///./src/utils/type.js?");

/***/ })

/******/ });